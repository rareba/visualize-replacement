define(["@grafana/data","@grafana/runtime","react","@emotion/css","@grafana/ui"],function(e,t,n,a,s){return function(){"use strict";var r={7:function(e){e.exports=s},89:function(e){e.exports=a},531:function(e){e.exports=t},781:function(t){t.exports=e},959:function(e){e.exports=n}},i={};function l(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={exports:{}};return r[e](n,n.exports,l),n.exports}l.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return l.d(t,{a:t}),t},l.d=function(e,t){for(var n in t)l.o(t,n)&&!l.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},l.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},l.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};l.r(o),l.d(o,{plugin:function(){return T}});var c=l(781),u=l(531);const d={limit:1e4},p="\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\nPREFIX cube: <https://cube.link/>\nPREFIX cubeMeta: <https://cube.link/meta/>\nPREFIX schema: <http://schema.org/>\nPREFIX sh: <http://www.w3.org/ns/shacl#>\nPREFIX qudt: <http://qudt.org/schema/qudt/>\nPREFIX dcterms: <http://purl.org/dc/terms/>\nPREFIX dcat: <http://www.w3.org/ns/dcat#>\nPREFIX time: <http://www.w3.org/2006/time#>\n";class h extends c.DataSourceApi{constructor(e){super(e),this.cubesCache=null,this.cubesCacheTime=0,this.metadataCache=new Map,this.CACHE_TTL=3e5,this.endpoint=e.jsonData?.endpoint||"https://lindas.admin.ch/query"}async testDatasource(){try{const e=`${p} SELECT ?cube WHERE { ?cube a cube:Cube } LIMIT 1`;return(await this.executeSparql(e)).results.bindings.length>0?{status:"success",message:"Successfully connected to LINDAS"}:{status:"error",message:"Connected but no cubes found"}}catch(e){return{status:"error",message:`Failed to connect to LINDAS: ${e.message||"Unknown error"}`}}}async executeSparql(e){try{return await(0,u.getBackendSrv)().post(this.endpoint,`query=${encodeURIComponent(e)}`,{headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/sparql-results+json"}})}catch(t){throw console.error("SPARQL query failed:",t),console.error("Query was:",e),t}}async getCubes(){if(this.cubesCache&&Date.now()-this.cubesCacheTime<this.CACHE_TTL)return this.cubesCache;const e=`${p}\nSELECT DISTINCT ?cube ?title ?description ?publisher ?datePublished WHERE {\n  ?cube a cube:Cube .\n\n  # Get title (with language fallback)\n  OPTIONAL {\n    ?cube schema:name ?titleDe .\n    FILTER(LANG(?titleDe) = "de")\n  }\n  OPTIONAL {\n    ?cube schema:name ?titleEn .\n    FILTER(LANG(?titleEn) = "en")\n  }\n  OPTIONAL {\n    ?cube schema:name ?titleAny .\n    FILTER(LANG(?titleAny) = "")\n  }\n  BIND(COALESCE(?titleDe, ?titleEn, ?titleAny, STR(?cube)) AS ?title)\n\n  # Get description\n  OPTIONAL {\n    ?cube schema:description ?descDe .\n    FILTER(LANG(?descDe) = "de")\n  }\n  OPTIONAL {\n    ?cube schema:description ?descEn .\n    FILTER(LANG(?descEn) = "en")\n  }\n  BIND(COALESCE(?descDe, ?descEn, "") AS ?description)\n\n  # Get publisher/creator\n  OPTIONAL {\n    ?cube dcterms:creator ?creatorIri .\n    ?creatorIri schema:name ?publisherName .\n    FILTER(LANG(?publisherName) = "de" || LANG(?publisherName) = "en" || LANG(?publisherName) = "")\n  }\n  BIND(COALESCE(?publisherName, "") AS ?publisher)\n\n  # Get date published\n  OPTIONAL { ?cube schema:datePublished ?datePublished }\n\n  # Filter: must have observations (not empty cubes)\n  FILTER EXISTS { ?cube cube:observationSet/cube:observation ?obs }\n}\nORDER BY DESC(?datePublished) ?title\nLIMIT 500`;try{console.log("Fetching cubes from LINDAS...");const t=await this.executeSparql(e);return console.log("Got cubes result:",t.results.bindings.length,"cubes"),this.cubesCache=t.results.bindings.map(e=>({uri:e.cube?.value||"",label:e.title?.value||"Unknown",description:e.description?.value,publisher:e.publisher?.value,datePublished:e.datePublished?.value})),this.cubesCacheTime=Date.now(),this.cubesCache}catch(e){return console.error("Failed to fetch cubes:",e),[]}}async getCubeMetadata(e){if(this.metadataCache.has(e))return this.metadataCache.get(e);const t=`${p}\nSELECT DISTINCT\n  ?dimension\n  ?label\n  ?dataKind\n  ?scaleType\n  ?unit\n  ?order\nWHERE {\n  <${e}> cube:observationConstraint ?shape .\n  ?shape sh:property ?prop .\n  ?prop sh:path ?dimension .\n\n  # Skip rdf:type and cube:observedBy\n  FILTER(?dimension != rdf:type && ?dimension != cube:observedBy)\n\n  # Get label\n  OPTIONAL {\n    ?prop schema:name ?labelDe .\n    FILTER(LANG(?labelDe) = "de")\n  }\n  OPTIONAL {\n    ?prop schema:name ?labelEn .\n    FILTER(LANG(?labelEn) = "en")\n  }\n  OPTIONAL {\n    ?prop rdfs:label ?labelRdfs .\n  }\n  BIND(COALESCE(?labelDe, ?labelEn, ?labelRdfs, STRAFTER(STR(?dimension), "#"), REPLACE(STR(?dimension), "^.*/", "")) AS ?label)\n\n  # Get data kind (for temporal detection)\n  OPTIONAL {\n    ?prop cubeMeta:dataKind/a ?dataKindType .\n    BIND(STRAFTER(STR(?dataKindType), "cube.link/") AS ?dataKind)\n  }\n\n  # Get scale type\n  OPTIONAL {\n    ?prop qudt:scaleType ?scaleTypeIri .\n    BIND(STRAFTER(STR(?scaleTypeIri), "qudt.org/vocab/scales/") AS ?scaleType)\n  }\n\n  # Get unit (indicates this is a measure)\n  OPTIONAL { ?prop qudt:unit ?unitIri . BIND(STR(?unitIri) AS ?unit) }\n  OPTIONAL { ?prop qudt:hasUnit ?hasUnitIri . BIND(STR(?hasUnitIri) AS ?unit) }\n  OPTIONAL { ?prop schema:unitCode ?unitCode . BIND(?unitCode AS ?unit) }\n\n  # Get order\n  OPTIONAL { ?prop sh:order ?order }\n}\nORDER BY ?order ?label`;try{console.log("Fetching metadata for cube:",e);const n=await this.executeSparql(t);console.log("Got structure result:",n.results.bindings.length,"properties");const a=[],s=[];for(const e of n.results.bindings){const t=e.dimension?.value||"",n=e.label?.value||t,r=e.unit?.value,i=e.scaleType?.value,l=e.dataKind?.value;r?s.push({uri:t,label:n,unit:r}):a.push({uri:t,label:n,scaleType:i,dataKind:l})}const r=(await this.getCubes()).find(t=>t.uri===e),i={uri:e,label:r?.label||e,description:r?.description,publisher:r?.publisher,dimensions:a,measures:s};return this.metadataCache.set(e,i),i}catch(e){return console.error("Failed to fetch cube metadata:",e),null}}buildDataQuery(e,t,n){const a=[],s=[];return s.push(`<${e}> cube:observationSet/cube:observation ?obs .`),t.dimensions.forEach((e,t)=>{const n=this.uriToVarName(e.uri,`dim${t}`),r=`${n}_raw`,i=`${n}_label`;a.push(`?${n}`),s.push(`OPTIONAL { ?obs <${e.uri}> ?${r} . }`),s.push("OPTIONAL {"),s.push(`  ?${r} schema:name ?${i}_de .`),s.push(`  FILTER(LANG(?${i}_de) = "de")`),s.push("}"),s.push("OPTIONAL {"),s.push(`  ?${r} schema:name ?${i}_en .`),s.push(`  FILTER(LANG(?${i}_en) = "en")`),s.push("}"),s.push("OPTIONAL {"),s.push(`  ?${r} schema:name ?${i}_any .`),s.push(`  FILTER(LANG(?${i}_any) = "")`),s.push("}"),s.push(`BIND(COALESCE(?${i}_de, ?${i}_en, ?${i}_any, STR(?${r})) AS ?${n})`)}),t.measures.forEach((e,t)=>{const n=this.uriToVarName(e.uri,`measure${t}`);a.push(`?${n}`),s.push(`OPTIONAL { ?obs <${e.uri}> ?${n} . }`)}),`${p}\nSELECT ${a.join(" ")} WHERE {\n  ${s.join("\n  ")}\n}\nLIMIT ${n}`}uriToVarName(e,t){const n=e.split(/[/#]/);return(n[n.length-1]||t).replace(/[^a-zA-Z0-9]/g,"_").replace(/^[0-9]/,"_$&").toLowerCase()}async query(e){const t=e.targets.filter(e=>!e.hide&&e.cubeUri).map(async e=>{const t={...d,...e};if(!t.cubeUri)return new c.MutableDataFrame({refId:e.refId,fields:[]});try{const n=await this.getCubeMetadata(t.cubeUri);if(!n)throw new Error(`Could not load metadata for cube: ${t.cubeUri}`);if(0===n.dimensions.length&&0===n.measures.length)throw new Error(`Cube has no dimensions or measures: ${t.cubeUri}`);const a=this.buildDataQuery(t.cubeUri,n,t.limit||1e4);console.log("Executing data query for:",t.cubeUri);const s=await this.executeSparql(a);return console.log("Got data result:",s.results.bindings.length,"rows"),this.toDataFrame(s,e.refId,n)}catch(e){throw console.error("Query failed:",e),e}});return{data:await Promise.all(t)}}toDataFrame(e,t,n){const a=new c.MutableDataFrame({refId:t,fields:[]});if(!e.results.bindings.length)return console.log("No data returned from query"),a;const s={};n.dimensions.forEach(e=>{const t=this.uriToVarName(e.uri,"");t&&(s[t]=e.label)}),n.measures.forEach(e=>{const t=this.uriToVarName(e.uri,"");t&&(s[t]=e.unit?`${e.label} (${e.unit})`:e.label)});const r=e.head.vars,i={};for(const t of r){let n=!0,a=!1,s=!1;for(let r=0;r<Math.min(20,e.results.bindings.length);r++){const i=e.results.bindings[r][t];if(i&&i.value){s=!0;const e=i.datatype||"";e.includes("integer")||e.includes("decimal")||e.includes("float")||e.includes("double")||(e.includes("date")||e.includes("dateTime")||e.includes("gYear")?(a=!0,n=!1):isNaN(Number(i.value))&&(n=!1))}}i[t]=s?a?c.FieldType.time:n?c.FieldType.number:c.FieldType.string:c.FieldType.string}for(const e of r)a.addField({name:e,type:i[e]||c.FieldType.string,config:{displayName:s[e]||e}});for(const t of e.results.bindings){const e=[];for(const n of r){const a=t[n]?.value,s=i[n];null==a?e.push(null):s===c.FieldType.number?e.push(Number(a)):s===c.FieldType.time?/^\d{4}$/.test(a)?e.push(new Date(parseInt(a,10),0,1).getTime()):e.push(new Date(a).getTime()):e.push(a)}a.appendRow(e)}return a}async metricFindQuery(e,t){return(await this.getCubes()).map(e=>({text:e.label,value:e.uri}))}}var b=l(959),m=l.n(b),g=l(89),f=l(7);const E=e=>({container:g.css`
    display: flex;
    flex-direction: column;
    gap: ${e.spacing(2)};
    max-width: 600px;
  `,info:g.css`
    padding: ${e.spacing(2)};
    background: ${e.colors.background.secondary};
    border-radius: ${e.shape.radius.default};

    h4 {
      margin: 0 0 ${e.spacing(1)} 0;
    }

    p {
      margin: 0 0 ${e.spacing(1)} 0;
      color: ${e.colors.text.secondary};

      &:last-child {
        margin-bottom: 0;
      }
    }
  `}),y=e=>({container:g.css`
    display: flex;
    flex-direction: column;
    gap: ${e.spacing(1)};
  `,loadingContainer:g.css`
    display: flex;
    align-items: center;
    gap: ${e.spacing(1)};
    padding: ${e.spacing(1)};
    color: ${e.colors.text.secondary};
  `,select:g.css`
    min-width: 300px;
  `,selectedInfo:g.css`
    display: flex;
    align-items: center;
    gap: ${e.spacing(1)};
    padding: ${e.spacing(.5)} ${e.spacing(1)};
    background: ${e.colors.background.secondary};
    border-radius: ${e.shape.radius.default};
    font-size: ${e.typography.size.sm};
  `,selectedLabel:g.css`
    color: ${e.colors.text.secondary};
  `,selectedValue:g.css`
    color: ${e.colors.text.primary};
    font-weight: ${e.typography.fontWeightMedium};
  `,selectedPublisher:g.css`
    color: ${e.colors.text.disabled};
  `}),T=new c.DataSourcePlugin(h).setConfigEditor(function(e){const t=(0,f.useStyles2)(E);return m().createElement("div",{className:t.container},m().createElement(f.Alert,{title:"LINDAS Datasource",severity:"info"},"This datasource connects to the Swiss Linked Data Service (LINDAS). No configuration is required - the connection is pre-configured."),m().createElement("div",{className:t.info},m().createElement("h4",null,"About LINDAS"),m().createElement("p",null,"LINDAS (Linked Data Service) is the Swiss Federal Administration's platform for publishing and accessing open government data as Linked Data."),m().createElement("p",null,m().createElement("strong",null,"Endpoint:")," https://lindas.admin.ch/query"),m().createElement("p",null,"When you create a panel, simply select a dataset from the dropdown. The data will be automatically fetched and displayed in tabular format.")))}).setQueryEditor(function({datasource:e,query:t,onChange:n,onRunQuery:a}){const s=(0,f.useStyles2)(y),[r,i]=(0,b.useState)([]),[l,o]=(0,b.useState)(!0),[c,u]=(0,b.useState)(null);(0,b.useEffect)(()=>{let t=!1;return(async()=>{o(!0),u(null);try{const n=await e.getCubes();t||i(n)}catch(e){t||u(`Failed to load datasets: ${e.message||"Unknown error"}`)}finally{t||o(!1)}})(),()=>{t=!0}},[e]);const p=r.map(e=>({label:e.label,value:e.uri,description:e.publisher||void 0})),h=p.find(e=>e.value===t.cubeUri),g=(0,b.useCallback)(e=>{const s=r.find(t=>t.uri===e.value);n({...t,cubeUri:e.value,cubeLabel:s?.label||e.label}),a()},[r,n,a,t]),E=[{label:"100 rows",value:100},{label:"1,000 rows",value:1e3},{label:"10,000 rows",value:1e4},{label:"50,000 rows",value:5e4}],T=E.find(e=>e.value===(t.limit||d.limit)),I=(0,b.useCallback)(e=>{n({...t,limit:e.value}),t.cubeUri&&a()},[n,a,t]);return c?m().createElement(f.Alert,{title:"Error",severity:"error"},c):m().createElement("div",{className:s.container},m().createElement(f.InlineFieldRow,null,m().createElement(f.InlineField,{label:"Dataset",labelWidth:12,tooltip:"Select a LINDAS dataset to visualize",grow:!0},l?m().createElement("div",{className:s.loadingContainer},m().createElement(f.Spinner,{size:"sm"}),m().createElement("span",null,"Loading datasets...")):m().createElement(f.Select,{options:p,value:h,onChange:g,placeholder:"Select a dataset...",isClearable:!0,isSearchable:!0,menuPlacement:"bottom",className:s.select})),m().createElement(f.InlineField,{label:"Limit",labelWidth:8,tooltip:"Maximum number of rows to return"},m().createElement(f.Select,{options:E,value:T,onChange:I,width:20}))),t.cubeUri&&h&&m().createElement("div",{className:s.selectedInfo},m().createElement("span",{className:s.selectedLabel},"Selected:"),m().createElement("span",{className:s.selectedValue},h.label),h.description&&m().createElement("span",{className:s.selectedPublisher},"(",h.description,")")))});return o}()});