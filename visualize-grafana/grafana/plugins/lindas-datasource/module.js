define(["@grafana/data","@grafana/runtime","react","@emotion/css","@grafana/ui"],function(e,a,t,n,s){return function(){"use strict";var r={7:function(e){e.exports=s},89:function(e){e.exports=n},531:function(e){e.exports=a},781:function(a){a.exports=e},959:function(e){e.exports=t}},l={};function i(e){var a=l[e];if(void 0!==a)return a.exports;var t=l[e]={exports:{}};return r[e](t,t.exports,i),t.exports}i.n=function(e){var a=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(a,{a:a}),a},i.d=function(e,a){for(var t in a)i.o(a,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:a[t]})},i.o=function(e,a){return Object.prototype.hasOwnProperty.call(e,a)},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};i.r(o),i.d(o,{plugin:function(){return N}});var c=i(781),u=i(531);const d={limit:1e4},p="\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\nPREFIX cube: <https://cube.link/>\nPREFIX schema: <http://schema.org/>\nPREFIX sh: <http://www.w3.org/ns/shacl#>\nPREFIX qudt: <http://qudt.org/schema/qudt/>\n";class b extends c.DataSourceApi{constructor(e){super(e),this.cubesCache=null,this.cubesCacheTime=0,this.CACHE_TTL=3e5,this.endpoint=e.jsonData?.endpoint||"https://lindas.admin.ch/query"}async testDatasource(){try{const e=`${p} SELECT ?cube WHERE { ?cube a cube:Cube } LIMIT 1`;return await this.executeSparql(e),{status:"success",message:"Successfully connected to LINDAS"}}catch(e){return{status:"error",message:`Failed to connect to LINDAS: ${e.message||"Unknown error"}`}}}async executeSparql(e){return await(0,u.getBackendSrv)().post(this.endpoint,`query=${encodeURIComponent(e)}`,{headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/sparql-results+json"}})}async getCubes(){if(this.cubesCache&&Date.now()-this.cubesCacheTime<this.CACHE_TTL)return this.cubesCache;const e=`${p}\nSELECT DISTINCT ?cube ?label ?description ?publisher WHERE {\n  ?cube a cube:Cube .\n\n  OPTIONAL {\n    ?cube schema:name ?labelRaw .\n    FILTER(LANG(?labelRaw) = "en" || LANG(?labelRaw) = "de" || LANG(?labelRaw) = "")\n  }\n  OPTIONAL {\n    ?cube schema:description ?descRaw .\n    FILTER(LANG(?descRaw) = "en" || LANG(?descRaw) = "de" || LANG(?descRaw) = "")\n  }\n  OPTIONAL {\n    ?cube schema:creator/schema:name ?publisherName .\n    FILTER(LANG(?publisherName) = "en" || LANG(?publisherName) = "de" || LANG(?publisherName) = "")\n  }\n\n  BIND(COALESCE(?labelRaw, STR(?cube)) AS ?label)\n  BIND(COALESCE(?descRaw, "") AS ?description)\n  BIND(COALESCE(?publisherName, "") AS ?publisher)\n}\nORDER BY ?label\nLIMIT 500`;try{const a=await this.executeSparql(e);return this.cubesCache=a.results.bindings.map(e=>({uri:e.cube?.value||"",label:e.label?.value||"Unknown",description:e.description?.value,publisher:e.publisher?.value})),this.cubesCacheTime=Date.now(),this.cubesCache}catch(e){return console.error("Failed to fetch cubes:",e),[]}}async getCubeMetadata(e){const a=`${p}\nSELECT DISTINCT ?dimension ?label ?scaleType WHERE {\n  <${e}> cube:observationConstraint ?shape .\n  ?shape sh:property ?prop .\n  ?prop sh:path ?dimension .\n\n  # Exclude measures (properties with units)\n  FILTER NOT EXISTS { ?prop qudt:unit ?unit }\n  FILTER NOT EXISTS { ?prop schema:unitCode ?unitCode }\n\n  OPTIONAL { ?prop schema:name ?propLabel . FILTER(LANG(?propLabel) = "en" || LANG(?propLabel) = "de" || LANG(?propLabel) = "") }\n  OPTIONAL { ?prop rdfs:label ?rdfsLabel . FILTER(LANG(?rdfsLabel) = "en" || LANG(?rdfsLabel) = "de" || LANG(?rdfsLabel) = "") }\n  OPTIONAL { ?prop <https://cube.link/meta/scaleType> ?scaleType }\n\n  BIND(COALESCE(?propLabel, ?rdfsLabel, STR(?dimension)) AS ?label)\n}\nORDER BY ?label`,t=`${p}\nSELECT DISTINCT ?measure ?label ?unit WHERE {\n  <${e}> cube:observationConstraint ?shape .\n  ?shape sh:property ?prop .\n  ?prop sh:path ?measure .\n\n  # Measures have units\n  { ?prop qudt:unit ?unitUri }\n  UNION { ?prop schema:unitCode ?unitCode }\n  UNION { ?prop qudt:hasUnit ?hasUnit }\n\n  OPTIONAL { ?prop schema:name ?propLabel . FILTER(LANG(?propLabel) = "en" || LANG(?propLabel) = "de" || LANG(?propLabel) = "") }\n  OPTIONAL { ?prop rdfs:label ?rdfsLabel . FILTER(LANG(?rdfsLabel) = "en" || LANG(?rdfsLabel) = "de" || LANG(?rdfsLabel) = "") }\n  OPTIONAL { ?unitUri rdfs:label ?unitLabel }\n\n  BIND(COALESCE(?propLabel, ?rdfsLabel, STR(?measure)) AS ?label)\n  BIND(COALESCE(?unitLabel, ?unitCode, STR(?unitUri)) AS ?unit)\n}\nORDER BY ?label`;try{const[n,s]=await Promise.all([this.executeSparql(a),this.executeSparql(t)]),r=(await this.getCubes()).find(a=>a.uri===e);return{uri:e,label:r?.label||e,description:r?.description,publisher:r?.publisher,dimensions:n.results.bindings.map(e=>({uri:e.dimension?.value||"",label:e.label?.value||"Unknown",scaleType:e.scaleType?.value})),measures:s.results.bindings.map(e=>({uri:e.measure?.value||"",label:e.label?.value||"Unknown",unit:e.unit?.value}))}}catch(e){return console.error("Failed to fetch cube metadata:",e),null}}buildDataQuery(e,a,t){const n=[],s=[];return s.push(`<${e}> cube:observationSet/cube:observation ?obs .`),a.dimensions.forEach((e,a)=>{const t=this.uriToVarName(e.uri,`dim${a}`),r=`${t}_raw`,l=`${t}_label`;n.push(`?${t}`),s.push(`OPTIONAL { ?obs <${e.uri}> ?${r} . }`),s.push(`OPTIONAL { ?${r} schema:name ?${l} . FILTER(LANG(?${l}) = "en" || LANG(?${l}) = "de" || LANG(?${l}) = "") }`),s.push(`BIND(COALESCE(?${l}, STR(?${r})) AS ?${t})`)}),a.measures.forEach((e,a)=>{const t=this.uriToVarName(e.uri,`measure${a}`);n.push(`?${t}`),s.push(`OPTIONAL { ?obs <${e.uri}> ?${t} . }`)}),`${p}\nSELECT ${n.join(" ")} WHERE {\n  ${s.join("\n  ")}\n}\nLIMIT ${t}`}uriToVarName(e,a){const t=e.split(/[/#]/);return(t[t.length-1]||a).replace(/[^a-zA-Z0-9]/g,"_").toLowerCase()}async query(e){const a=e.targets.filter(e=>!e.hide&&e.cubeUri).map(async e=>{const a={...d,...e};if(!a.cubeUri)return new c.MutableDataFrame({refId:e.refId,fields:[]});try{const t=await this.getCubeMetadata(a.cubeUri);if(!t)throw new Error(`Could not load metadata for cube: ${a.cubeUri}`);const n=this.buildDataQuery(a.cubeUri,t,a.limit||1e4),s=await this.executeSparql(n);return this.toDataFrame(s,e.refId,t)}catch(e){throw console.error("Query failed:",e),e}});return{data:await Promise.all(a)}}toDataFrame(e,a,t){const n=new c.MutableDataFrame({refId:a,fields:[]});if(!e.results.bindings.length)return n;const s={};t.dimensions.forEach(e=>{const a=this.uriToVarName(e.uri,"");a&&(s[a]=e.label)}),t.measures.forEach(e=>{const a=this.uriToVarName(e.uri,"");a&&(s[a]=e.label)});const r=e.head.vars,l={};for(const a of r){let t=!0,n=!1;for(let s=0;s<Math.min(10,e.results.bindings.length);s++){const r=e.results.bindings[s][a];r&&(r.datatype?.includes("integer")||r.datatype?.includes("decimal")||r.datatype?.includes("float")||r.datatype?.includes("double")?t=!0:r.datatype?.includes("date")||r.datatype?.includes("dateTime")?(n=!0,t=!1):isNaN(Number(r.value))&&(t=!1))}l[a]=n?c.FieldType.time:t?c.FieldType.number:c.FieldType.string}for(const e of r)n.addField({name:e,type:l[e]||c.FieldType.string,config:{displayName:s[e]||e}});for(const a of e.results.bindings){const e=[];for(const t of r){const n=a[t]?.value,s=l[t];null==n?e.push(null):s===c.FieldType.number?e.push(Number(n)):s===c.FieldType.time?e.push(new Date(n).getTime()):e.push(n)}n.appendRow(e)}return n}async metricFindQuery(e,a){return(await this.getCubes()).map(e=>({text:e.label,value:e.uri}))}}var m=i(959),h=i.n(m),f=i(89),L=i(7);const E=e=>({container:f.css`
    display: flex;
    flex-direction: column;
    gap: ${e.spacing(2)};
    max-width: 600px;
  `,info:f.css`
    padding: ${e.spacing(2)};
    background: ${e.colors.background.secondary};
    border-radius: ${e.shape.radius.default};

    h4 {
      margin: 0 0 ${e.spacing(1)} 0;
    }

    p {
      margin: 0 0 ${e.spacing(1)} 0;
      color: ${e.colors.text.secondary};

      &:last-child {
        margin-bottom: 0;
      }
    }
  `}),g=e=>({container:f.css`
    display: flex;
    flex-direction: column;
    gap: ${e.spacing(1)};
  `,loadingContainer:f.css`
    display: flex;
    align-items: center;
    gap: ${e.spacing(1)};
    padding: ${e.spacing(1)};
    color: ${e.colors.text.secondary};
  `,select:f.css`
    min-width: 300px;
  `,selectedInfo:f.css`
    display: flex;
    align-items: center;
    gap: ${e.spacing(1)};
    padding: ${e.spacing(.5)} ${e.spacing(1)};
    background: ${e.colors.background.secondary};
    border-radius: ${e.shape.radius.default};
    font-size: ${e.typography.size.sm};
  `,selectedLabel:f.css`
    color: ${e.colors.text.secondary};
  `,selectedValue:f.css`
    color: ${e.colors.text.primary};
    font-weight: ${e.typography.fontWeightMedium};
  `,selectedPublisher:f.css`
    color: ${e.colors.text.disabled};
  `}),N=new c.DataSourcePlugin(b).setConfigEditor(function(e){const a=(0,L.useStyles2)(E);return h().createElement("div",{className:a.container},h().createElement(L.Alert,{title:"LINDAS Datasource",severity:"info"},"This datasource connects to the Swiss Linked Data Service (LINDAS). No configuration is required - the connection is pre-configured."),h().createElement("div",{className:a.info},h().createElement("h4",null,"About LINDAS"),h().createElement("p",null,"LINDAS (Linked Data Service) is the Swiss Federal Administration's platform for publishing and accessing open government data as Linked Data."),h().createElement("p",null,h().createElement("strong",null,"Endpoint:")," https://lindas.admin.ch/query"),h().createElement("p",null,"When you create a panel, simply select a dataset from the dropdown. The data will be automatically fetched and displayed in tabular format.")))}).setQueryEditor(function({datasource:e,query:a,onChange:t,onRunQuery:n}){const s=(0,L.useStyles2)(g),[r,l]=(0,m.useState)([]),[i,o]=(0,m.useState)(!0),[c,u]=(0,m.useState)(null);(0,m.useEffect)(()=>{let a=!1;return(async()=>{o(!0),u(null);try{const t=await e.getCubes();a||l(t)}catch(e){a||u(`Failed to load datasets: ${e.message||"Unknown error"}`)}finally{a||o(!1)}})(),()=>{a=!0}},[e]);const p=r.map(e=>({label:e.label,value:e.uri,description:e.publisher||void 0})),b=p.find(e=>e.value===a.cubeUri),f=(0,m.useCallback)(e=>{const s=r.find(a=>a.uri===e.value);t({...a,cubeUri:e.value,cubeLabel:s?.label||e.label}),n()},[r,t,n,a]),E=[{label:"100 rows",value:100},{label:"1,000 rows",value:1e3},{label:"10,000 rows",value:1e4},{label:"50,000 rows",value:5e4}],N=E.find(e=>e.value===(a.limit||d.limit)),y=(0,m.useCallback)(e=>{t({...a,limit:e.value}),a.cubeUri&&n()},[t,n,a]);return c?h().createElement(L.Alert,{title:"Error",severity:"error"},c):h().createElement("div",{className:s.container},h().createElement(L.InlineFieldRow,null,h().createElement(L.InlineField,{label:"Dataset",labelWidth:12,tooltip:"Select a LINDAS dataset to visualize",grow:!0},i?h().createElement("div",{className:s.loadingContainer},h().createElement(L.Spinner,{size:"sm"}),h().createElement("span",null,"Loading datasets...")):h().createElement(L.Select,{options:p,value:b,onChange:f,placeholder:"Select a dataset...",isClearable:!0,isSearchable:!0,menuPlacement:"bottom",className:s.select})),h().createElement(L.InlineField,{label:"Limit",labelWidth:8,tooltip:"Maximum number of rows to return"},h().createElement(L.Select,{options:E,value:N,onChange:y,width:20}))),a.cubeUri&&b&&h().createElement("div",{className:s.selectedInfo},h().createElement("span",{className:s.selectedLabel},"Selected:"),h().createElement("span",{className:s.selectedValue},b.label),b.description&&h().createElement("span",{className:s.selectedPublisher},"(",b.description,")")))});return o}()});